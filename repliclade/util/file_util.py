from Bio import SeqIO
from Bio.Blast import NCBIXML
from datetime import datetime
from repliclade.util.seq_util import SequenceUtil
from repliclade.settings.settings import ReplicladeSettings
import os
import json
import glob


class FileStream(object):
    @staticmethod
    def most_recent_file():
        """
        Gets most recent file from the last alignment performed
        """
        path_to_file = ReplicladeSettings.ALIGNMENTS_PATH + "*.aln"
        list_of_files = glob.glob(path_to_file)
        latest_file = max(list_of_files, key=os.path.getctime)
        print("Taking most recent file: {}".format(latest_file))
        return latest_file

    @staticmethod
    def most_recent_file_results():
        """
        Gets the most recent results json file
        """
        path_to_file = ReplicladeSettings.RESULTS_PATH + "*.json"
        list_of_files = glob.glob(path_to_file)
        latest_file = max(list_of_files, key=os.path.getctime)
        return latest_file

    @staticmethod
    def most_recent_fasta_results(self):
        """
        Gets the most recent results fasta file
        """
        path_to_file = ReplicladeSettings.RESULTS_PATH + "*.fasta"
        list_of_files = glob.glob(path_to_file)
        latest_file = max(list_of_files, key=os.path.getctime)
        return latest_file

    @staticmethod
    def most_recent_dnd_results():
        """
        Gets the most recent results dnd file
        """
        path_to_file = ReplicladeSettings.RESULTS_PATH + "*.dnd"
        list_of_files = glob.glob(path_to_file)
        latest_file = max(list_of_files, key=os.path.getctime)
        return latest_file

    def read_from_alignment(self):
        """
        Reads sequences from the most recent alignment file

        Outputs an array of aligned sequences
        """
        alignment_file = self.most_recent_file()
        aligned_seqs = []

        with open(alignment_file, "rU") as handle:
            for record in SeqIO.parse(handle, "clustal"):
                aligned_seqs.append(str(record.seq))

        return aligned_seqs

    def read_from_alignment_results(self):
        """
        Reads sequences from the most recent alignment file

        Outputs an array of aligned sequences
        """
        alignment_file = self.most_recent_file()
        aligned_seqs = []

        with open(alignment_file, "rU") as handle:
            for record in SeqIO.parse(handle, "clustal"):
                aligned_seqs.append((str(record.seq), str(record.id)))

        return aligned_seqs

    @staticmethod
    def read_from_fasta(gene_name):
        """
        reads from input fasta file before running the sequence against the BLAST algorithm
        """
        fasta_file = ReplicladeSettings.FASTAS_PATH + "{}.fasta".format(gene_name)
        fasta_seqs = []

        with open(fasta_file, "rU") as handle:
            for record in SeqIO.parse(handle, "fasta"):
                fasta_seqs.append(str(record.seq))

        return fasta_seqs

    @staticmethod
    def read_from_blast_fasta(filename):
        """
        Reads sequences from the fasta file generated by the blast function and used in the alignment
        """
        fasta_file = ReplicladeSettings.DNA_PATH + "{}.fasta".format(filename)
        fasta_seqs = []

        with open(fasta_file, "rU") as handle:
            for record in SeqIO.parse(handle, "fasta"):
                fasta_seqs.append((str(record.seq), record.id))

        return fasta_seqs

    def read_from_blast(self, filename):
        """
        Reads results from BLAST algorithm and returns them in an array of tuples
        """
        blast_file_path = ReplicladeSettings.DNA_PATH + "{}.xml".format(filename)
        blast_seqs = []
        result_handle = open(blast_file_path)
        blast_records = NCBIXML.read(result_handle)
        for alignment in blast_records.alignments:
            if len(alignment.hsps) > 1:
                best_hsp = self.find_best_hsp(alignment.hsps)
                print("****Alignment****")
                print("sequence:", alignment.title)
                print("length:", alignment.length)
                print("e value:", best_hsp.expect)
                print(best_hsp.query[0:75] + "...")
                print(best_hsp.match[0:75] + "...")
                print(best_hsp.sbjct[0:75] + "...")
                blast_seqs.append((alignment.title, best_hsp.sbjct))
            else:
                for hsp in alignment.hsps:
                    print("****Alignment****")
                    print("sequence:", alignment.title)
                    print("length:", alignment.length)
                    print("e value:", hsp.expect)
                    print(hsp.query[0:75] + "...")
                    print(hsp.match[0:75] + "...")
                    print(hsp.sbjct[0:75] + "...")
                    blast_seqs.append((alignment.title, hsp.sbjct))
        return blast_seqs

    @staticmethod
    def find_best_hsp(hsps):
        """
        Finds best matching hsp's for hsp's in a multiple hsp hit from BLAST
        """
        max_score = -9999999
        best_hsp = None
        for hsp in hsps:
            if hsp.score > max_score:
                max_score = hsp.score
                best_hsp = hsp
        return best_hsp

    @staticmethod
    def write_to_fasta_sim_results(sequences, nodes, filename_original):

        seq_obj = SequenceUtil()
        filename_original = filename_original.replace(".fasta", "").replace(
            ".FASTA", ""
        )
        filename = "simulation_results_{}".format(seq_obj.get_time())

        with open(
            ReplicladeSettings.DNA_PATH + "{}.fasta".format(filename), "w"
        ) as open_file:
            for seq in sequences:
                for node in nodes:
                    if node.get_sequence() == seq:
                        open_file.write(
                            ">{0}\n{1}\n".format(
                                filename_original + "_sim_" + str(node.num), seq
                            )
                        )
        return filename

    @staticmethod
    def write_to_fasta_blast(sequences, filename):
        """
        writes blast sequences to fasta
        """
        with open(
            ReplicladeSettings.DNA_PATH + "{}.fasta".format(filename), "w"
        ) as open_file:
            for seq in sequences:
                open_file.write(">{0}\n{1}\n".format(seq[0], seq[1]))

    @staticmethod
    def write_to_fasta_results(seq_id, sequences):
        with open(
            ReplicladeSettings.RESULTS_PATH
            + "{}_results.fasta".format(seq_id.replace("|", "")),
            "w",
        ) as open_file:
            for i in range(len(sequences)):
                open_file.write(">{0}Gen{1}\n{2}\n".format(seq_id, i, sequences[i]))

    @staticmethod
    def write_to_fasta_results_multiple(seq_ids, sequences):
        with open(
            ReplicladeSettings.RESULTS_PATH + "post_sim_results.fasta", "w"
        ) as open_file:
            for i in range(len(sequences)):
                open_file.write(">{0}\n{1}\n".format(seq_ids[i], sequences[i]))

    @staticmethod
    def log_simulation_to_json(generation_dict):
        """
        Save results from each generation into a json file
        """
        date_time = datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
        filename = "sim_results_{}.json".format(date_time)
        with open(ReplicladeSettings.RESULTS_PATH + filename, "w") as open_file:
            open_file.write(json.dumps(generation_dict))
        print(
            "Results written to {}".format(ReplicladeSettings.RESULTS_PATH + filename)
        )

    @staticmethod
    def log_simulation_output_to_json(output_dict):
        date_time = datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
        filename = "sim_output_{}.json".format(date_time)
        with open(ReplicladeSettings.RESULTS_PATH + filename, "w") as open_file:
            open_file.write(json.dumps(output_dict))
        print(
            "Results written to {}".format(ReplicladeSettings.RESULTS_PATH + filename)
        )

    def read_simulation_results(self):
        latest_file_path = self.most_recent_file_results()
        generation_dict = json.loads(latest_file_path)
        return generation_dict
